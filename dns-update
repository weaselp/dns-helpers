#!/usr/bin/perl
# vim:set ai noet sts=8 ts=8 sw=8 tw=0:
# Local Variables:
# mode:cperl
# cperl-indent-level:4
# End:

# Copyright Â© Stephen Gran 2009
#
# Author: Stephen Gran <steve@lobefin.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, under version 2 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

use strict;
use warnings;
use English;
use File::Temp qw(tempfile);
use YAML;

my $conffile = '/etc/dns-helpers.yaml';
$conffile = $ENV{'DNSHELPERS_CONF'} if defined $ENV{'DNSHELPERS_CONF'};

my $config = YAML::LoadFile $conffile;

for my $key (qw{indir outdir postcommand updatecommand named_snippet}) {
	die ("$key not set in config\n") unless defined $config->{$key};
};

our $INDIR = $config->{'indir'};
our $OUTDIR = $config->{'outdir'};
our @postcommand = @{$config->{'postcommand'}};
our $update_command = $config->{'updatecommand'};
our $named_snippet = $config->{'named_snippet'};


sub check_files {
	my @cmd = qw(git diff --name-only);
	push @cmd, (join '..', @_);
	open(FILES, '-|', @cmd) or die "git log failed? $!\n";
	my @files = (<FILES>);
	close FILES or die "git log exited non-zero? $!\n";
	chomp(@files);
	return @files;
}

sub do_update {
	my @changes = @_;
	delete $ENV{'GIT_DIR'};
	chdir $INDIR or die "chdir $INDIR failed? $!\n";
	my @cmd = qw(git pull);
	system(@cmd) == 0 or die "system @cmd failed: $?\n";
	
	for my $file (@changes)  {
		next if ( -l "$INDIR/$file" ); # ignore symlinks
		next if ( $file =~ m#/# ); # ignore files not in the repository's /
		next unless ( -f "$INDIR/$file" );
		print "Updating $file ...\n";
		system($update_command, $file);
		warn("$update_command $file returned non-zero exit status ".($CHILD_ERROR >> 8).".\n") if ($CHILD_ERROR >> 8 != 0);
		print "done.\n";
	}

	opendir (D, $INDIR) or die "Can't opendir $INDIR: $!\n";
	my @zones = grep { $_ !~ /^\./  && -f "$INDIR/$_" } readdir D;
	closedir D;

	my ($zonefd, $zonefile) = tempfile(DIR => $OUTDIR);

	for my $file (@zones) {
		my $zonename = $file; 
		$zonename =~ s/\@/\//;
		my $snip = $named_snippet;
		$snip =~ s#\@\@ZONEFILE\@\@#$OUTDIR/$file#g;
		$snip =~ s#\@\@ZONENAME\@\@#$zonename#g;
		print $zonefd $snip;
		unless (-f "$OUTDIR/$file") {
			print "Updating $file (missing) ...\n";
			system($update_command, $file);
			warn("$update_command $file returned non-zero exit status ".($CHILD_ERROR >> 8).".\n") if ($CHILD_ERROR >> 8 != 0);
			print "done.\n";
		}
	}

	close $zonefd;
	chmod(0664, $zonefile);
	rename $zonefile, "$OUTDIR/named.conf";
	
	system(@postcommand) == 0 or die "system @postcommand failed: $?\n";
}

umask(0002);
for my $key (keys %ENV) {
	next if ($key eq 'GIT_DIR');
	delete $ENV{$key};
}
$ENV{'PATH'} = '/bin:/usr/bin:/sbin:/usr/sbin';

my @files;

while (<>) {
	my ($oldrev, $newrev, $refname) = split;
	push @files, (check_files($newrev, $oldrev));
}

my %files;
for my $file (@files) {
	$files{$file}++;
}

do_update(keys %files);

