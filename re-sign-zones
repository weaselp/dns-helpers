#!/usr/bin/perl

# Copyright (c) 2010 Peter Palfrader <peter@palfrader.org>
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


=head1 NAME

re-sign-zones - Re-sign dnssec secured zone files

=head1 SYNOPSIS

re-sign-zones [B<--force>] [B<--verbose>] [B<--dry-run>] [I<zone> [I<zone> ...]]

re-sign-zones B<--help>


=head1 DESCRIPTION

B<re-sign-zones> loops over all the zone files in the configured input
directory or all the zones given on the command line.  It then passes
them to B<write_zonefile> for recreation (and thus re-signing) if

=over

=item

the zonefile's last signing time is more than
I<dnssec_signature_publication_period> in the past, or

=item

if the zones key information changed more recently than
the last signing, or

=item

the B<--force> option is used.

=back

Last signing time is determined by the mtime of the zonefile and its companion
F<.serial> state file in the output directory.

Last zone key information is taken from B<Net::DNS::SEC::Maint::Key>'s
key database.



=head1 FILES

=over

=item F</etc/dns-helpers.yaml>

Config file location.

=back


=head1 ENVIRONMENT

=over

=item B<DNSHELPERS_CONF>

Overrides location for the configuration file.

=item B<DNSSECMAINT_CONFFILE>

Location for the  B<Net::DNS::SEC::Maint::Key> configuration file.

=back


=head1 SEE ALSO

=over

=item F<dns-helpers.yaml.sample>

=item B<named-checkzone>

=item B<dns-update>

=item B<maintkeydb>

=item B<dnssigner>

=item B<write_zonefile>

=back

=cut

use strict;
use warnings;
use English;
use YAML;
use Net::DNS::SEC::Maint::Key;
use List::Util qw[max min];
use File::stat;
use File::Basename;
use Getopt::Long;

use FindBin;
use lib $FindBin::Bin;
use DSA::DNSHelpers;


my ($KEYDB);

sub last_key_change {
	my $zone = shift;
	my @keys = $KEYDB->get_all($zone);
	return undef if (scalar @keys == 0);
	my $max = max(map {$_->get_state_change} @keys);
	return $max;
};

sub last_zone_rebuild {
	my $zone = shift;
	my $filenames = shift;

	my $zonefile = stat($filenames->{'zone'});
	my $serialfile = stat($filenames->{'serial'});
	return 0 unless (defined $zonefile && defined $serialfile);
	return min($zonefile->mtime, $serialfile->mtime);
}

sub find_zones {
	my ($indir, $zfdir, $serialdir, $zones) = @_;

	opendir INDIR, $indir or die ("Cannot opendir $indir\n");
	for my $file (readdir INDIR) {
		next if ( -l "$indir/$file" );
		next unless ( -f "$indir/$file" );
		next if $file =~ /^(dsset|keyset)-/;

		my $zone = $file;
		$zone =~ s/\.zone$//;

		my $zf = $zfdir.'/'.$zone;
		$zf = $zfdir.'/db.'.$zone unless -e $zf;

		$zones->{$zone} = { 'zone' => $zf,
		                    'serial' => $serialdir.'/'.$zone.'.serial' };
	}
	closedir(INDIR);
};



my $USAGE = "Usage: $PROGRAM_NAME [--help] | [--force] [--verbose] [--dry-run] [zone [zone...]]\n";
my $params;
Getopt::Long::config('bundling');
GetOptions (
	'--help' => \$params->{'help'},
	'--force' => \$params->{'force'},
	'--dry-run' => \$params->{'dry-run'},
	'--verbose' => \$params->{'verbose'},
) or die ($USAGE);
if ($params->{'help'}) {
        print $USAGE;
        exit(0);
};


my $config = load_config(qw{indir outdir updatecommand postcommand dnssec_signature_publication_period});

$KEYDB = Net::DNS::SEC::Maint::Key->new(1);
my $update_command = $config->{'updatecommand'};
our @postcommand = @{$config->{'postcommand'}};
my $dnssec_signature_publication_period = convert_time($config->{'dnssec_signature_publication_period'});
my $skew = 5*60;



my %zones;

find_zones($config->{'indir'}, $config->{'outdir'}, $config->{'outdir'}, \%zones);
if (defined $config->{'indir-geo'} && defined $config->{'outdir-geo'} && defined $config->{'serialdir-geo'}) {
	find_zones($config->{'indir-geo'}, $config->{'outdir-geo'}, $config->{'serialdir-geo'}, \%zones);
}

if (scalar @ARGV) {
	my %newzones;
	for my $zone (@ARGV) {
		unless ($zones{$zone}) {
			print STDERR "No files found for zone $zone\n";
			next;
		};
		$newzones{$zone} = $zones{$zone}
	};
	%zones = %newzones;
};

my $updates = 0;
my $now = time();
# Process files from longest zonename to shortest.
# This is to ensure we deal with any child zones before we
# handle their respective parent zone.
# E.g. we do rbl.debian.net before debian.net, thus
# producing the dnssec related file dsset-rbl.debian.net,
# which is included in the debian.net zone, before we
# go and create/sign the debian.net zone.
for my $zone (sort {length($b) <=> length($a)} keys %zones) {
	my $last_key_change = last_key_change($zone);
	unless (defined $last_key_change) {
		print STDERR "No keys for zone $zone\n" if $params->{'verbose'};
		next;
	};

	my $last_zone_rebuild = last_zone_rebuild($zone, $zones{$zone});

	my $rebuild = 0;
	$rebuild = 1 if ($last_zone_rebuild - $skew < $last_key_change);
	$rebuild = 1 if ($last_zone_rebuild - $skew < $now - $dnssec_signature_publication_period);
	$rebuild = 1 if $params->{'force'};
	unless ($rebuild) {
		print STDERR "Skipping $zone\n" if $params->{'verbose'};
		next;
	}

	print STDERR "Updating $zone\n" if $params->{'verbose'};
	$updates++;
	unless ($params->{'dry-run'}) {
		system($update_command, $zone);
		warn("$update_command $zone returned non-zero exit status ".($CHILD_ERROR >> 8).".\n") if ($CHILD_ERROR >> 8 != 0);
	};
};

if ($updates > 0 and !$params->{'verbose'}) {
	system(@postcommand) == 0 or die "system @postcommand failed: $?\n";
};
