#!/usr/bin/perl
# vim:set ai noet sts=8 ts=8 sw=8 tw=0:
# Local Variables:
# mode:cperl
# cperl-indent-level:4
# End:

# Copyright Â© Stephen Gran 2009
# Copyright (c) 2010 Peter Palfrader <peter@palfrader.org>
#
# Author: Stephen Gran <steve@lobefin.net>, Peter Palfrader
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, under version 2 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA


=head1 NAME

write_zonefile - Add SOA to and optionally sign a zonefile


=head1 SYNOPSIS

write_zonefile <zonename>


=head1 DESCRIPTION

Reads a (partial) zonefile from I<INDIR>/I<zonename> and writes a complete
zonefile to I<OUTDIR>/I<zonename>.

Unless DNSSEC is enabled for a zone, the only processing this script does is
adding a $TTL default line at the top, and then adding a SOA before including
the input zone in verbatim.

The script keeps some state in I<OUTDIR>/I<zonename>B<.serial> about which
serial number to put in the SOA.  It makes strictly incrementing serials, of
the I<yyyymmddNN> style (overflowing to the next day if it runs out of numbers
for a day).

If B<named-checkzone> likes the new zonefile this scripts exits with 0 exit
code and the new zonefile in the output directory.  Otherwise it exits with a
non-zero code and without modifying the zonefile in the output directory.

If DNSSEC is enabled for a zone, B<dnssigner> is called for the zonefile
produced as described above and the resulting signed zone is placed in the
output directory.


=head1 CONFIGURATION OPTIONS

The configuration file specifies a number of options, including SOA values.
See B<dns-helpers.yaml.sample> for an example.  Some of these options
can be overriden on a per-zone basis by having lines of the form
C<wzf: I<key> = I<value>> in your input zonefile.  Valid keys include
B<dnssec> (if set to B<1> enables dnssec for this zone),
B<dnssec_signature_validity_period>, B<dnssec_keyttl>,
B<soa_>{B<origin>,B<hostmaster>,B<refresh>,B<retry>,B<expire>,B<negttl>},
and B<default_ttl>.


=head1 FILES

=over

=item F</etc/dns-helpers.yaml>

Config file location.

=back


=head1 ENVIRONMENT

=over

=item B<DNSHELPERS_CONF>

Overrides location for the configuration file.

=back


=head1 SEE ALSO

=over

=item F<dns-helpers.yaml.sample>

=item B<named-checkzone>

=item B<dns-update>

=item B<maintkeydb>

=item B<dnssigner>

=item B<re-sign-zones>

=back

=cut

use strict;
use warnings;
use POSIX qw(strftime);
use File::Temp qw(tempfile);
use English;
use YAML;

use FindBin;
use lib $FindBin::Bin;
use DSA::DNSHelpers;

my $conffile = '/etc/dns-helpers.yaml';
$conffile = $ENV{'DNSHELPERS_CONF'} if defined $ENV{'DNSHELPERS_CONF'};

my $config = YAML::LoadFile $conffile;

for my $key (qw{indir outdir default_ttl soa}) {
	die ("$key not set in config\n") unless defined $config->{$key};
};

our $INDIR = $config->{'indir'};
our $OUTDIR = $config->{'outdir'};
our $DEFAULT_TTL = $config->{'default_ttl'};
our $SOA = $config->{'soa'};

chdir($INDIR) || die ("Cannot chdir to $INDIR: $!\n");

sub convert_time {
	my $ticks = shift;
	my $unit = shift;

	unless (defined $unit) {
		my $newticks;
		($newticks, $unit) = $ticks =~ m/^(\d*)([smhdw]?)$/;
		if (!defined $newticks) {
			print STDERR "Warning: invalid timestring to convert '$ticks'\n";
			return $ticks;
		}
		$ticks = $newticks;
	}

	if ($unit eq 's' || $unit eq '') { }
	elsif ($unit eq 'm') { $ticks *= 60; }
	elsif ($unit eq 'h') { $ticks *= 60*60; }
	elsif ($unit eq 'd') { $ticks *= 60*60*24; }
	elsif ($unit eq 'w') { $ticks *= 60*60*24*7; }
	else { print STDERR "Warning: invalid unit '$unit'\n" }
	return $ticks;
}


my $zonename = shift @ARGV;
die "Usage: $0 <zonename>\n" unless defined $zonename && length($zonename);


my $do_dnssec = 0;
my $dnssec_signature_validity_period = undef;
my $dnssec_key_ttl = undef;
$dnssec_signature_validity_period = convert_time($config->{'dnssec_signature_validity_period'}) if defined $config->{'dnssec_signature_validity_period'};
$dnssec_key_ttl = $config->{'dnssec_key_ttl'} if defined $config->{'dnssec_key_ttl'};

open(INFILE, '<', "$INDIR/$zonename") or die "Can't open $INDIR/$zonename: $!\n";
my $lineno = 0;
my @lines = ();
while (<INFILE>) {
	$lineno++;
	push @lines, $_;
	chomp;

	if (/^; wzf:\s*dnssec\s*=\s*1\s*$/) { $do_dnssec = 1 }
	elsif (/^; wzf:\s*dnssec_signature_validity_period\s*=\s*(\d+)([smhdw]?)\s*$/) { $dnssec_signature_validity_period = convert_time($1, $2) }
	elsif (/^; wzf:\s*dnssec_keyttl\s*=\s*(\d*)([smhdw]?)\s*$/) { $dnssec_key_ttl = convert_time($1, $2) }
	elsif (/^; wzf:\s*soa_(origin|hostmaster|refresh|retry|expire|negttl)\s*=\s*(\S*)\s*$/) { $SOA->{$1} = $2 }
	elsif (/^; wzf:\s*default_ttl\s*=\s*(\S*)\s*$/) { $DEFAULT_TTL = $1 }
	elsif (/^; wzf:/) {
		print STDERR "Unknown wzf directive in line $lineno: '$_'\n";
	};
};
close INFILE;



my $serial = new_serial($zonename, $OUTDIR);
my ($fd, $tmpzonefilename) = tempfile(DIR => $OUTDIR, SUFFIX => '.tmp');

print $fd generate_zoneheader($serial, ttl => $DEFAULT_TTL, %$SOA);
for (@lines) {
	print $fd $_;
};

close $fd;
chmod(0664, $tmpzonefilename);

if ($do_dnssec) {
	my $ret = sign_zonefile($zonename, $tmpzonefilename,
		$config->{'dnssigner'},
		$dnssec_key_ttl, $dnssec_signature_validity_period);

	if (!defined $ret) {
		unlink $tmpzonefilename;
		die("ERROR: dnssigner returned errors on zone $zonename - aborted update.\n");
	};
};

if (! check_zonefile($zonename, $tmpzonefilename)) {
	unlink $tmpzonefilename;
	die("ERROR: checkzone returned errors on zone $zonename - not updated.\n");
}
rename $tmpzonefilename, "$OUTDIR/$zonename";
